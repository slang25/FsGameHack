declare const FSymbol: any;
export { FSymbol as Symbol };
export interface IComparer<T> {
    Compare(x: T, y: T): number;
}
export interface IComparable<T> {
    CompareTo(x: T): number;
}
export interface IEquatable<T> {
    Equals(x: T): boolean;
}
export declare type Tuple<T1, T2> = [T1, T2];
export declare type Tuple3<T1, T2, T3> = [T1, T2, T3];
export declare function Tuple<T1, T2>(x: T1, y: T2): [T1, T2];
export declare function Tuple3<T1, T2, T3>(x: T1, y: T2, z: T3): [T1, T2, T3];
export declare class Util {
    static setInterfaces(proto: any, interfaces: string[], typeName?: string): void;
    static hasInterface(obj: any, ...interfaceNames: string[]): any;
    static getTypeFullName(cons: any): string;
    static getTypeNamespace(cons: any): string;
    static getTypeName(cons: any): string;
    static getRestParams(args: ArrayLike<any>, idx: number): any[];
    static toString(o: any): any;
    static equals(x: any, y: any): boolean;
    static compare(x: any, y: any): number;
    static equalsRecords(x: any, y: any): boolean;
    static compareRecords(x: any, y: any): number;
    static equalsUnions(x: any, y: any): boolean;
    static compareUnions(x: any, y: any): number;
    static createDisposable(f: () => void): IDisposable;
    static createObj(fields: Iterable<Tuple<string, any>>): any;
    static toPlainJsObj: (source: any) => any;
}
export declare class Serialize {
    static toJson(o: any): string;
    static ofJson(json: any, expected?: Function): any;
}
export declare class GenericComparer<T> implements IComparer<T> {
    Compare: (x: T, y: T) => number;
    constructor(f?: (x: T, y: T) => number);
}
export declare class Choice<T1, T2> {
    Case: "Choice1Of2" | "Choice2Of2";
    Fields: Array<T1 | T2>;
    constructor(t: "Choice1Of2" | "Choice2Of2", d: T1[] | T2[]);
    static Choice1Of2<T1, T2>(v: T1): Choice<T1, T2>;
    static Choice2Of2<T1, T2>(v: T2): Choice<T1, T2>;
    valueIfChoice1: T1;
    valueIfChoice2: T2;
    Equals(other: Choice<T1, T2>): boolean;
    CompareTo(other: Choice<T1, T2>): number;
}
export declare class TimeSpan extends Number {
    static create(d?: number, h?: number, m?: number, s?: number, ms?: number): number;
    static fromTicks(ticks: number): number;
    static fromDays(d: number): number;
    static fromHours(h: number): number;
    static fromMinutes(m: number): number;
    static fromSeconds(s: number): number;
    static days(ts: TimeSpan): number;
    static hours(ts: TimeSpan): number;
    static minutes(ts: TimeSpan): number;
    static seconds(ts: TimeSpan): number;
    static milliseconds(ts: TimeSpan): number;
    static ticks(ts: TimeSpan): number;
    static totalDays(ts: TimeSpan): number;
    static totalHours(ts: TimeSpan): number;
    static totalMinutes(ts: TimeSpan): number;
    static totalSeconds(ts: TimeSpan): number;
    static negate(ts: TimeSpan): number;
    static add(ts1: TimeSpan, ts2: TimeSpan): number;
    static subtract(ts1: TimeSpan, ts2: TimeSpan): number;
    static compare: typeof Util.compare;
    static compareTo: typeof Util.compare;
    static duration: (x: number) => number;
}
export declare enum DateKind {
    UTC = 1,
    Local = 2,
}
declare class FDate extends Date {
    kind: DateKind;
    private static __changeKind(d, kind);
    private static __getValue(d, key);
    static minValue(): any;
    static maxValue(): any;
    static parse(v?: any, kind?: DateKind): any;
    static create(year: number, month: number, day: number, h?: number, m?: number, s?: number, ms?: number, kind?: DateKind): Date;
    static now: typeof FDate.parse;
    static utcNow(): any;
    static today(): Date;
    static isLeapYear(year: number): boolean;
    static daysInMonth(year: number, month: number): number;
    static toUniversalTime(d: Date): Date;
    static toLocalTime(d: Date): Date;
    static timeOfDay(d: Date): number;
    static date(d: Date): Date;
    static day(d: Date): number;
    static hour(d: Date): number;
    static millisecond(d: Date): number;
    static minute(d: Date): number;
    static month(d: Date): number;
    static second(d: Date): number;
    static year(d: Date): number;
    static ticks(d: Date): number;
    static toBinary: typeof FDate.ticks;
    static dayOfWeek(d: Date): number;
    static dayOfYear(d: Date): number;
    static add(d: Date, ts: TimeSpan): any;
    static addDays(d: Date, v: number): any;
    static addHours(d: Date, v: number): any;
    static addMinutes(d: Date, v: number): any;
    static addSeconds(d: Date, v: number): any;
    static addMilliseconds(d: Date, v: number): any;
    static addTicks(d: Date, v: number): any;
    static addYears(d: Date, v: number): Date;
    static addMonths(d: Date, v: number): Date;
    static subtract(d: Date, that: Date | number): any;
    static toLongDateString(d: Date): string;
    static toShortDateString(d: Date): string;
    static toLongTimeString(d: Date): string;
    static toShortTimeString(d: Date): string;
    static equals(d1: Date, d2: Date): boolean;
    static compareTo: typeof Util.compare;
    static compare: typeof Util.compare;
    static op_Addition: typeof FDate.add;
    static op_Subtraction: typeof FDate.subtract;
}
export { FDate as Date };
export interface IDisposable {
    Dispose(): void;
}
export declare class Timer implements IDisposable {
    Interval: number;
    AutoReset: boolean;
    private _elapsed;
    private _enabled;
    private _isDisposed;
    private _intervalId;
    private _timeoutId;
    constructor(interval?: number);
    Elapsed: Event<Date>;
    Enabled: boolean;
    Dispose(): void;
    Close(): void;
    Start(): void;
    Stop(): void;
}
declare class FString {
    private static fsFormatRegExp;
    static fsFormat(str: string): (cont: any) => any;
    private static formatRegExp;
    static format(str: string, ...args: any[]): string;
    static endsWith(str: string, search: string): boolean;
    static initialize(n: number, f: (i: number) => string): string;
    static isNullOrEmpty(str: string | any): boolean;
    static isNullOrWhiteSpace(str: string | any): boolean;
    static join(delimiter: string, xs: ArrayLike<string>): string;
    static newGuid(): string;
    static padLeft(str: any, len: number, ch?: string, isRight?: boolean): any;
    static padRight(str: any, len: number, ch?: string): any;
    static replace(str: string, search: string, replace: string): string;
    static replicate(n: number, x: string): string;
    static split(str: string, splitters: string[], count?: number, removeEmpty?: number): string[];
    static trim(str: string, side: "start" | "end" | "both", ...chars: string[]): string;
}
export { FString as String };
export declare type MatchEvaluator = (match: any) => string;
declare class FRegExp {
    static create(pattern: string, options: number): RegExp;
    static escape(str: string): string;
    static unescape(str: string): string;
    static isMatch(str: string | RegExp, pattern: string, options?: number): boolean;
    static match(str: string | RegExp, pattern: string, options?: number): RegExpExecArray;
    static matches(str: string | RegExp, pattern: string, options?: number): RegExpExecArray[];
    static options(reg: RegExp): number;
    static replace(reg: string | RegExp, input: string, replacement: string | MatchEvaluator, limit?: number, offset?: number): string;
    static split(reg: string | RegExp, input: string, limit?: number, offset?: number): string[];
}
export { FRegExp as RegExp };
declare class FArray {
    static addRangeInPlace<T>(range: Iterable<T>, xs: Array<T>): void;
    static copyTo<T>(source: ArrayLike<T>, sourceIndex: number, target: ArrayLike<T>, targetIndex: number, count: number): void;
    static partition<T>(f: (x: T) => boolean, xs: ArrayLike<T>): [T[], T[]];
    static permute<T>(f: (i: number) => number, xs: Array<T>): T[];
    static removeInPlace<T>(item: T, xs: Array<T>): boolean;
    static setSlice<T>(target: any, lower: number, upper: number, source: ArrayLike<T>): void;
    static sortInPlaceBy<T>(f: (x: T) => T, xs: Array<T>, dir?: number): T[];
    static unzip<T1, T2>(xs: ArrayLike<Tuple<T1, T2>>): [T1[], T2[]];
    static unzip3<T1, T2, T3>(xs: ArrayLike<Tuple3<T1, T2, T3>>): [T1[], T2[], T3[]];
}
export { FArray as Array };
export declare class List<T> implements IEquatable<List<T>>, IComparable<List<T>>, Iterable<T> {
    head: T;
    tail: List<T>;
    constructor(head?: T, tail?: List<T>);
    ToString(): string;
    Equals(x: List<T>): boolean;
    CompareTo(x: List<T>): number;
    static ofArray<T>(args: Array<T>, base?: List<T>): List<T>;
    length: number;
    [Symbol.iterator](): Iterator<T>;
    append(ys: List<T>): List<T>;
    static append<T>(xs: List<T>, ys: List<T>): List<T>;
    choose<U>(f: (x: T) => U, xs: List<T>): List<U>;
    static choose<T, U>(f: (x: T) => U, xs: List<T>): List<U>;
    collect<U>(f: (x: T) => List<U>): List<U>;
    static collect<T, U>(f: (x: T) => List<U>, xs: List<T>): List<U>;
    static concat<T>(xs: List<List<T>>): List<T>;
    filter(f: (x: T) => boolean): List<T>;
    static filter<T>(f: (x: T) => boolean, xs: List<T>): List<T>;
    where(f: (x: T) => boolean): List<T>;
    static where<T>(f: (x: T) => boolean, xs: List<T>): List<T>;
    static initialize<T>(n: number, f: (i: number) => T): List<T>;
    map<U>(f: (x: T) => U): List<U>;
    static map<T, U>(f: (x: T) => U, xs: List<T>): List<U>;
    mapIndexed<U>(f: (i: number, x: T) => U): List<U>;
    static mapIndexed<T, U>(f: (i: number, x: T) => U, xs: List<T>): List<U>;
    partition(f: (x: T) => boolean): [List<T>, List<T>];
    static partition<T>(f: (x: T) => boolean, xs: List<T>): [List<T>, List<T>];
    static replicate<T>(n: number, x: T): List<T>;
    reverse(): List<T>;
    static reverse<T>(xs: List<T>): List<T>;
    static singleton<T>(x: T): List<T>;
    slice(lower: number, upper: number): List<T>;
    static slice<T>(lower: number, upper: number, xs: List<T>): List<T>;
    static unzip<T1, T2>(xs: List<Tuple<T1, T2>>): [List<T1>, List<T2>];
    static unzip3<T1, T2, T3>(xs: List<Tuple3<T1, T2, T3>>): [List<T1>, List<T2>, List<T3>];
}
export declare class Seq {
    private static __failIfNone<T>(res);
    static toList<T>(xs: Iterable<T>): List<T>;
    static ofList<T>(xs: List<T>): Iterable<T>;
    static ofArray<T>(xs: ArrayLike<T>): Iterable<T>;
    static append<T>(xs: Iterable<T>, ys: Iterable<T>): Iterable<T>;
    static average(xs: Iterable<number>): number;
    static averageBy(f: (a: number) => number, xs: Iterable<number>): number;
    static countBy<T, K>(f: (x: T) => K, xs: Iterable<T>): Iterable<[K, number]>;
    static concat<T>(xs: Iterable<Iterable<T>>): Iterable<T>;
    static collect<T, U>(f: (x: T) => Iterable<U>, xs: Iterable<T>): Iterable<U>;
    static choose<T, U>(f: (x: T) => U, xs: Iterable<T>): Iterable<U>;
    static compareWith<T>(f: (x: T, y: T) => number, xs: Iterable<T>, ys: Iterable<T>): number;
    static delay<T>(f: () => Iterable<T>): Iterable<T>;
    static distinctBy<T, K>(f: (x: T) => K, xs: Iterable<T>): Iterable<T>;
    static distinct<T>(xs: Iterable<T>): Iterable<T>;
    static empty<T>(): Iterable<T>;
    static enumerateWhile<T>(cond: () => boolean, xs: Iterable<T>): Iterable<T>;
    static enumerateThenFinally<T>(xs: Iterable<T>, finalFn: () => void): Iterable<T>;
    static enumerateUsing<T extends IDisposable, U>(disp: T, work: (x: T) => Iterable<U>): Iterable<U>;
    static exactlyOne<T>(xs: Iterable<T>): T;
    static except<T>(itemsToExclude: Iterable<T>, source: Iterable<T>): Iterable<T>;
    static exists<T>(f: (x: T) => boolean, xs: Iterable<T>): boolean;
    static exists2<T1, T2>(f: (x: T1, y: T2) => boolean, xs: Iterable<T1>, ys: Iterable<T2>): boolean;
    static filter<T>(f: (x: T) => boolean, xs: Iterable<T>): Iterable<T>;
    static where<T>(f: (x: T) => boolean, xs: Iterable<T>): Iterable<T>;
    static fold<T, ST>(f: (acc: ST, x: T, i?: number) => ST, acc: ST, xs: Iterable<T>): ST;
    static foldBack<T, ST>(f: (x: T, acc: ST, i?: number) => ST, xs: Iterable<T>, acc: ST): ST;
    static fold2<T1, T2, ST>(f: (acc: ST, x: T1, y: T2, i?: number) => ST, acc: ST, xs: Iterable<T1>, ys: Iterable<T2>): ST;
    static foldBack2<T1, T2, ST>(f: (x: T1, y: T2, acc: ST, i?: number) => ST, xs: Iterable<T1>, ys: Iterable<T2>, acc: ST): ST;
    static forAll<T>(f: (x: T) => boolean, xs: Iterable<T>): boolean;
    static forAll2<T1, T2>(f: (x: T1, y: T2) => boolean, xs: Iterable<T1>, ys: Iterable<T2>): boolean;
    static groupBy<T, K>(f: (x: T) => K, xs: Iterable<T>): Iterable<[K, Iterable<T>]>;
    static tryHead<T>(xs: Iterable<T>): T;
    static head<T>(xs: Iterable<T>): T;
    static initialize<T>(n: number, f: (i: number) => T): Iterable<T>;
    static initializeInfinite<T>(f: (i: number) => T): Iterable<T>;
    static tryItem<T>(i: number, xs: Iterable<T>): T;
    static item<T>(i: number, xs: Iterable<T>): T;
    static iterate<T>(f: (x: T) => void, xs: Iterable<T>): void;
    static iterate2<T1, T2>(f: (x: T1, y: T2) => void, xs: Iterable<T1>, ys: Iterable<T2>): void;
    static iterateIndexed<T>(f: (i: number, x: T) => void, xs: Iterable<T>): void;
    static iterateIndexed2<T1, T2>(f: (i: number, x: T1, y: T2) => void, xs: Iterable<T1>, ys: Iterable<T2>): void;
    static isEmpty<T>(xs: Iterable<T>): boolean;
    static tryLast<T>(xs: Iterable<T>): T;
    static last<T>(xs: Iterable<T>): T;
    static count<T>(xs: Iterable<T>): number;
    static map<T, U>(f: (x: T) => U, xs: Iterable<T>): Iterable<U>;
    static mapIndexed<T, U>(f: (i: number, x: T) => U, xs: Iterable<T>): Iterable<U>;
    static map2<T1, T2, U>(f: (x: T1, y: T2) => U, xs: Iterable<T1>, ys: Iterable<T2>): Iterable<U>;
    static mapIndexed2<T1, T2, U>(f: (i: number, x: T1, y: T2) => U, xs: Iterable<T1>, ys: Iterable<T2>): Iterable<U>;
    static map3<T1, T2, T3, U>(f: (x: T1, y: T2, z: T3) => U, xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Iterable<U>;
    static mapFold<T, ST, R>(f: (acc: ST, x: T) => Tuple<R, ST>, acc: ST, xs: Iterable<T>): [Iterable<R>, ST];
    static mapFoldBack<T, ST, R>(f: (x: T, acc: ST) => Tuple<R, ST>, xs: Iterable<T>, acc: ST): [Iterable<R>, ST];
    static max<T extends number>(xs: Iterable<T>): T;
    static maxBy<T, U extends number>(f: (x: T) => U, xs: Iterable<T>): T;
    static min<T extends number>(xs: Iterable<T>): T;
    static minBy<T, U extends number>(f: (x: T) => U, xs: Iterable<T>): T;
    static pairwise<T extends number>(xs: Iterable<T>): Iterable<[number, number]>;
    static permute<T>(f: (i: number) => number, xs: Iterable<T>): Iterable<T>;
    static rangeStep(first: number, step: number, last: number): Iterable<number>;
    static rangeChar(first: string, last: string): Iterable<string>;
    static range(first: number, last: number): Iterable<number>;
    static readOnly<T>(xs: Iterable<T>): Iterable<T>;
    static reduce<T>(f: (acc: T, x: T) => T, xs: Iterable<T>): T;
    static reduceBack<T>(f: (acc: T, x: T, i?: number) => T, xs: Iterable<T>): T;
    static replicate<T>(n: number, x: T): Iterable<T>;
    static reverse<T>(xs: Iterable<T>): Iterable<T>;
    static scan<T, ST>(f: (st: ST, x: T) => ST, seed: ST, xs: Iterable<T>): Iterable<ST>;
    static scanBack<T, ST>(f: (x: T, st: ST) => ST, xs: Iterable<T>, seed: ST): Iterable<ST>;
    static singleton<T>(x: T): Iterable<T>;
    static skip<T>(n: number, xs: Iterable<T>): Iterable<T>;
    static skipWhile<T>(f: (x: T) => boolean, xs: Iterable<T>): Iterable<T>;
    static sortWith<T>(f: (x: T, y: T) => number, xs: Iterable<T>): Iterable<T>;
    static sum(xs: Iterable<number>): number;
    static sumBy<T>(f: (x: T) => number, xs: Iterable<T>): number;
    static tail<T>(xs: Iterable<T>): Iterable<T>;
    static take<T>(n: number, xs: Iterable<T>, truncate?: boolean): Iterable<T>;
    static truncate<T>(n: number, xs: Iterable<T>): Iterable<T>;
    static takeWhile<T>(f: (x: T) => boolean, xs: Iterable<T>): Iterable<T>;
    static tryFind<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>, defaultValue?: T): T;
    static find<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>): T;
    static tryFindBack<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>, defaultValue?: T): T;
    static findBack<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>): T;
    static tryFindIndex<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>): number;
    static findIndex<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>): number;
    static tryFindIndexBack<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>): number;
    static findIndexBack<T>(f: (x: T, i?: number) => boolean, xs: Iterable<T>): number;
    static tryPick<T, U>(f: (x: T, i?: number) => U, xs: Iterable<T>): U;
    static pick<T, U>(f: (x: T, i?: number) => U, xs: Iterable<T>): U;
    static unfold<T, ST>(f: (st: ST) => Tuple<T, ST>, acc?: ST): Iterable<T>;
    static zip<T1, T2>(xs: Iterable<T1>, ys: Iterable<T2>): Iterable<(T1 | T2)[]>;
    static zip3<T1, T2, T3>(xs: Iterable<T1>, ys: Iterable<T2>, zs: Iterable<T3>): Iterable<(T1 | T2 | T3)[]>;
}
declare class FSet<T> implements IEquatable<FSet<T>>, IComparable<FSet<T>>, Iterable<T> {
    private tree;
    private comparer;
    /** Do not call, use Set.create instead. */
    constructor();
    private static from<T>(comparer, tree);
    static create<T>(ie?: Iterable<T>, comparer?: IComparer<T>): FSet<T>;
    ToString(): string;
    Equals(s2: FSet<T>): boolean;
    CompareTo(s2: FSet<T>): number;
    [Symbol.iterator](): Iterator<T>;
    values(): Iterator<T>;
    has(v: T): boolean;
    /** Not supported */
    add(v: T): FSet<T>;
    /** Not supported */
    delete(v: T): boolean;
    /** Not supported */
    clear(): void;
    size: number;
    static isEmpty<T>(s: FSet<T>): boolean;
    static add<T>(item: T, s: FSet<T>): FSet<T>;
    static addInPlace<T>(item: T, s: Set<T>): boolean;
    static remove<T>(item: T, s: FSet<T>): FSet<T>;
    static union<T>(set1: FSet<T>, set2: FSet<T>): FSet<T>;
    static op_Addition: typeof FSet.union;
    static unionInPlace<T>(set1: Set<T>, set2: Iterable<T>): void;
    static unionMany<T>(sets: Iterable<FSet<T>>): FSet<T>;
    static difference<T>(set1: FSet<T>, set2: FSet<T>): FSet<T>;
    static op_Subtraction: typeof FSet.difference;
    static differenceInPlace<T>(set1: Set<T>, set2: Iterable<T>): void;
    static intersect<T>(set1: FSet<T>, set2: FSet<T>): FSet<T>;
    static intersectInPlace<T>(set1: Set<T>, set2: Iterable<T>): void;
    static intersectMany<T>(sets: Iterable<FSet<T>>): FSet<T>;
    static isProperSubsetOf<T>(set1: FSet<T> | Set<T>, set2: FSet<T> | Set<T>): boolean;
    static isProperSubset: typeof FSet.isProperSubsetOf;
    static isSubsetOf<T>(set1: FSet<T> | Set<T>, set2: FSet<T> | Set<T>): boolean;
    static isSubset: typeof FSet.isSubsetOf;
    static isProperSupersetOf<T>(set1: FSet<T> | Set<T>, set2: FSet<T> | Set<T>): boolean;
    static isProperSuperset: typeof FSet.isProperSupersetOf;
    static isSupersetOf<T>(set1: FSet<T> | Set<T>, set2: FSet<T> | Set<T>): boolean;
    static isSuperset: typeof FSet.isSupersetOf;
    static copyTo<T>(xs: FSet<T> | Set<T>, arr: ArrayLike<T>, arrayIndex?: number, count?: number): void;
    static partition<T>(f: (x: T) => boolean, s: FSet<T>): [FSet<T>, FSet<T>];
    static filter<T>(f: (x: T) => boolean, s: FSet<T>): FSet<T>;
    static map<T, U>(f: (x: T) => U, s: FSet<T>): FSet<U>;
    static exists<T>(f: (x: T) => boolean, s: FSet<T>): boolean;
    static forAll<T>(f: (x: T) => boolean, s: FSet<T>): boolean;
    static fold<T, U>(f: (acc: U, x: T) => U, seed: U, s: FSet<T>): U;
    static foldBack<T, U>(f: (x: T, acc: U) => U, s: FSet<T>, seed: U): U;
    static iterate<T>(f: (v: T) => void, s: FSet<T>): void;
    static minimumElement<T>(s: FSet<T>): any;
    static minElement: typeof FSet.minimumElement;
    static maximumElement<T>(s: FSet<T>): any;
    static maxElement: typeof FSet.maximumElement;
}
export { FSet as Set };
declare class FMap<K, V> implements IEquatable<FMap<K, V>>, IComparable<FMap<K, V>>, Iterable<[K, V]> {
    private tree;
    private comparer;
    /** Do not call, use Map.create instead. */
    constructor();
    private static from<K, V>(comparer, tree);
    static create<K, V>(ie?: Iterable<[K, V]>, comparer?: IComparer<K>): FMap<K, {}>;
    ToString(): string;
    Equals(m2: FMap<K, V>): boolean;
    CompareTo(m2: FMap<K, V>): number;
    [Symbol.iterator](): Iterator<[K, V]>;
    entries(): Iterator<[K, V]>;
    keys(): Iterable<K>;
    values(): Iterable<V>;
    get(k: K): any;
    has(k: K): boolean;
    /** Not supported */
    set(k: K, v: V): FMap<K, V>;
    /** Not supported */
    delete(k: K): boolean;
    /** Not supported */
    clear(): void;
    size: number;
    static add<K, V>(k: K, v: V, map: FMap<K, V>): FMap<K, {}>;
    static remove<K, V>(item: K, map: FMap<K, V>): FMap<K, {}>;
    static containsValue<K, V>(v: V, map: Map<K, V> | FMap<K, V>): boolean;
    static exists<K, V>(f: (k: K, v: V) => boolean, map: FMap<K, V>): boolean;
    static find<K, V>(k: K, map: FMap<K, V>): any;
    static tryFind<K, V>(k: K, map: FMap<K, V>): any;
    static filter<K, V>(f: (k: K, v: V) => boolean, map: FMap<K, V>): FMap<K, {}>;
    static fold<K, V, ST>(f: (acc: ST, k: K, v: V) => ST, seed: ST, map: FMap<K, V>): any;
    static foldBack<K, V, ST>(f: (k: K, v: V, acc: ST) => ST, map: FMap<K, V>, seed: ST): any;
    static forAll<K, V>(f: (k: K, v: V) => boolean, map: FMap<K, V>): boolean;
    static isEmpty<K, V>(map: FMap<K, V>): boolean;
    static iterate<K, V>(f: (k: K, v: V) => void, map: FMap<K, V>): void;
    static map<K, T, U>(f: (k: K, v: T) => U, map: FMap<K, T>): FMap<K, {}>;
    static partition<K, V>(f: (k: K, v: V) => boolean, map: FMap<K, V>): FMap<K, {}>[];
    static findKey<K, V>(f: (k: K, v: V) => boolean, map: Map<K, V> | FMap<K, V>): K;
    static tryFindKey<K, V>(f: (k: K, v: V) => boolean, map: Map<K, V> | FMap<K, V>): K;
    static pick<K, T, U>(f: (k: K, v: T) => U, map: FMap<K, T>): any;
    static tryPick<K, T, U>(f: (k: K, v: T) => U, map: FMap<K, T>): any;
}
export { FMap as Map };
export declare type Unit = void;
export declare const Nothing: Unit;
export declare type Continuation<T> = (x: T) => Unit;
export interface CancellationToken {
    isCancelled: boolean;
}
export declare class Trampoline {
    private callCount;
    incrementAndCheck(): boolean;
    hijack(f: () => void): void;
}
export interface IAsyncContext<T> {
    onSuccess: Continuation<T>;
    onError: Continuation<any>;
    onCancel: Continuation<any>;
    cancelToken: CancellationToken;
    trampoline: Trampoline;
}
export declare type IAsync<T> = (x: IAsyncContext<T>) => void;
export declare class AsyncBuilder {
    Bind<T, U>(computation: IAsync<T>, binder: (x: T) => IAsync<U>): (ctx: IAsyncContext<U>) => void;
    Combine<T>(computation1: IAsync<Unit>, computation2: IAsync<T>): (ctx: IAsyncContext<T>) => void;
    Delay<T>(generator: () => IAsync<T>): (ctx: IAsyncContext<T>) => void;
    For<T>(sequence: Iterable<T>, body: (x: T) => IAsync<Unit>): (x: IAsyncContext<void>) => void;
    Return<T>(value?: T): (ctx: IAsyncContext<T>) => void;
    ReturnFrom<T>(computation: IAsync<T>): (x: IAsyncContext<T>) => void;
    TryFinally<T>(computation: IAsync<T>, compensation: () => void): (ctx: IAsyncContext<T>) => void;
    TryWith<T>(computation: IAsync<T>, catchHandler: (e: any) => IAsync<T>): (ctx: IAsyncContext<T>) => void;
    Using<T extends IDisposable, U>(resource: T, binder: (x: T) => IAsync<U>): (ctx: IAsyncContext<U>) => void;
    While(guard: () => boolean, computation: IAsync<Unit>): IAsync<Unit>;
    Zero(): (ctx: IAsyncContext<void>) => void;
    static singleton: AsyncBuilder;
}
export declare class Async {
    static awaitPromise<T>(p: Promise<T>): (ctx: IAsyncContext<T>) => void;
    static cancellationToken: (ctx: IAsyncContext<CancellationToken>) => void;
    static catch<T>(work: IAsync<T>): (ctx: IAsyncContext<Choice<T, any>>) => void;
    static defaultCancellationToken: {
        isCancelled: boolean;
    };
    static fromContinuations<T>(f: (conts: Array<Continuation<T>>) => void): (ctx: IAsyncContext<T>) => void;
    static ignore<T>(computation: IAsync<T>): (ctx: IAsyncContext<void>) => void;
    static parallel<T>(computations: Iterable<IAsync<T>>): (ctx: IAsyncContext<T[]>) => void;
    static sleep(millisecondsDueTime: number): (ctx: IAsyncContext<void>) => void;
    private static start<T>(computation, cancellationToken?);
    static startImmediate: typeof Async.start;
    private static emptyContinuation<T>(x);
    private static startWithContinuations<T>(computation, continuation?, exceptionContinuation?, cancellationContinuation?, cancelToken?);
    static startAsPromise<T>(computation: IAsync<T>, cancellationToken?: CancellationToken): Promise<T>;
}
export declare type MailboxBody<Msg> = (m: MailboxProcessor<Msg>) => IAsync<Unit>;
export interface AsyncReplyChannel<Reply> {
    reply: (r: Reply) => Unit;
}
export declare class MailboxProcessor<Msg> {
    private body;
    private cancellationToken;
    private messages;
    private continuation;
    constructor(body: MailboxBody<Msg>, cancellationToken?: CancellationToken);
    static start<Msg>(body: MailboxBody<Msg>, cancellationToken?: CancellationToken): MailboxProcessor<Msg>;
    __processEvents(): void;
    start(): void;
    receive(): (ctx: IAsyncContext<Msg>) => void;
    post(message: Msg): void;
    postAndAsyncReply<Reply>(buildMessage: (c: AsyncReplyChannel<Reply>) => Msg): (ctx: IAsyncContext<Reply>) => void;
}
export interface IObserver<T> {
    OnNext: (x: T) => void;
    OnError: (e: any) => void;
    OnCompleted: () => void;
}
export interface IObservable<T> {
    Subscribe: (o: IObserver<T>) => IDisposable;
}
declare class FObservable {
    static __protect<T>(f: () => T, succeed: (x: T) => void, fail: (e: any) => void): void;
    static add<T>(callback: (x: T) => Unit, source: IObservable<T>): void;
    static choose<T, U>(chooser: (x: T) => U, source: IObservable<T>): IObservable<U>;
    static filter<T>(predicate: (x: T) => boolean, source: IObservable<T>): IObservable<T>;
    static map<T, U>(mapping: (x: T) => U, source: IObservable<T>): IObservable<U>;
    static merge<T>(source1: IObservable<T>, source2: IObservable<T>): IObservable<T>;
    static pairwise<T>(source: IObservable<T>): IObservable<[T, T]>;
    static partition<T>(predicate: (x: T) => boolean, source: IObservable<T>): [IObservable<T>, IObservable<T>];
    static scan<U, T>(collector: (u: U, t: T) => U, state: U, source: IObservable<T>): IObservable<U>;
    static split<T, U1, U2>(splitter: (x: T) => Choice<U1, U2>, source: IObservable<T>): [IObservable<U1>, IObservable<U2>];
    static subscribe<T>(callback: (x: T) => Unit, source: IObservable<T>): IDisposable;
}
export { FObservable as Observable };
export declare type Delegate<T> = (x: T) => void;
export declare type DotNetDelegate<T> = (sender: any, x: T) => void;
export interface IDelegateEvent<T> {
    AddHandler(d: DotNetDelegate<T>): void;
    RemoveHandler(d: DotNetDelegate<T>): void;
}
export interface IEvent<T> extends IObservable<T>, IDelegateEvent<T> {
    Publish: IEvent<T>;
    Trigger(x: T): void;
}
export declare class Event<T> implements IEvent<T> {
    private _subscriber;
    private delegates;
    constructor(_subscriber?: (o: IObserver<T>) => IDisposable, delegates?: any[]);
    Add(f: Delegate<T>): void;
    Publish: this;
    Trigger(value: T): void;
    private _addHandler(f);
    private _removeHandler(f);
    AddHandler(handler: DotNetDelegate<T>): void;
    RemoveHandler(handler: DotNetDelegate<T>): void;
    private _subscribeFromObserver(observer);
    private _subscribeFromCallback(callback);
    Subscribe(arg: IObserver<T> | Delegate<T>): IDisposable;
    static add<T>(callback: (x: T) => Unit, sourceEvent: IEvent<T>): void;
    static choose<T, U>(chooser: (x: T) => U, sourceEvent: IEvent<T>): IEvent<U>;
    static filter<T>(predicate: (x: T) => boolean, sourceEvent: IEvent<T>): IEvent<T>;
    static map<T, U>(mapping: (x: T) => U, sourceEvent: IEvent<T>): IEvent<U>;
    static merge<T>(event1: IEvent<T>, event2: IEvent<T>): IEvent<T>;
    static pairwise<T>(sourceEvent: IEvent<T>): IEvent<[T, T]>;
    static partition<T>(predicate: (x: T) => boolean, sourceEvent: IEvent<T>): [IEvent<T>, IEvent<T>];
    static scan<U, T>(collector: (u: U, t: T) => U, state: U, sourceEvent: IEvent<T>): IEvent<U>;
    static split<T, U1, U2>(splitter: (x: T) => Choice<U1, U2>, sourceEvent: IEvent<T>): [IEvent<U1>, IEvent<U2>];
}
export declare class Lazy<T> {
    factory: () => T;
    isValueCreated: boolean;
    private createdValue;
    constructor(factory: () => T);
    static createFromValue<T>(v: T): Lazy<T>;
    value: T;
}
